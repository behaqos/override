Мейник:
Создаётся переменная cmd, ret, array

В цикле условие, если подан аргумент - забивать всё нулями, тем самым игнорировать содержимое
аргументов, которые подаются при запуске программы.
Далее в берётся переменная env, которая так же обнуляется. Как я понял это для того, чтобы мы
не закидывали уязвимости как argv либо через переменные окружения.
Дальше текст приветствия.
А затем запрос команды.
ret даётся значение 1.
Дальше получает команду через fgets ограничением памяти в 20 бит.
А затем отправляет по соответствующим командам функциям.
Если ret всё ещё один, то пишет, что команда провалилась при выполнении. Иначе пишет, что всё отлично.

Из чего состоит команда store?
Рассмотрим функцию store_number:

Создаёт так же три переменные:
значение, индекс и рет.
Получает число, записывает в unsigned int;
С индексом то же самое.
Затем проверяет - если число делится на 3 без остатка или значение после сдвига на 24 бита
будет равно 183, то выводит ошибку.
А в противном случае умножает индекс на 4 + массив, который был выделен в мейнике на 100 ячеек,
куда помещает значение и возвращает ret 0, чтобы показать успешное выполнение программы.

    *(index * 4 + array) = value;
Судя по программе, все значения с индексами должны храниться в массиве из 100 ячеек, но проверки
того, что номер индекса входит в рамках этих 100 ячеек нету. Только указанная выше проверка
на деление без остатка на 3 и на то, что значение не равно 183 после смещения на 24 бита.

А без проверки программой индекса куда хранить значение - мы можем делать запросы в стэк как
при уязвимости форматной строки.

Есть регистр EIP, который хранит специфичное значение - адрес следующей по порядку команды,
а затем выполняется и сама команда. Каждый раз к этому адресу прибавляется значение для перехода к следующей команде.
Обычно ассемблер сам этим занимается. 
Почему запись идёт на 114 индекс?
Ясно, что 114 делится на 3, поэтому хотят сделать так, чтобы переполнить и достичь 114 через
отрицательное число.
